<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Matrix Org Chart - Native Version</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background: #f0f2f5; }
        #canvas { background-color: white; cursor: grab; }
        #canvas:active { cursor: grabbing; }
        .controls {
            position: absolute; top: 10px; left: 10px;
            background: rgba(255,255,255,0.9); padding: 15px;
            border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            pointer-events: none;
        }
        .instruction { font-size: 14px; color: #666; }
    </style>
</head>
<body>
    <div class="controls">
        <strong>組織圖編輯器 (原生版)</strong><br>
        <span class="instruction">● 拖拽方塊可移動<br>● 點擊方塊觸發條件高亮</span>
    </div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // 設定畫布大小
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.onresize = resize;
        resize();

        // 節點資料與邏輯設定
        let nodes = [
            { id: 1, x: 400, y: 80, text: 'RD 部門', group: 'head', color: '#34495e' },
            { id: 2, x: 250, y: 180, text: '技術週會', group: 'meeting', color: '#2980b9' },
            { id: 3, x: 550, y: 180, text: '專案週會', group: 'meeting', color: '#2980b9' },
            { id: 4, x: 150, y: 280, text: 'Marcus', group: 'team-a', color: '#27ae60' },
            { id: 5, x: 350, y: 280, text: 'Jack', group: 'team-a', color: '#27ae60' }
        ];

        let selectedNode = null;
        let highlightedGroup = null;
        let isDragging = false;
        let offset = { x: 0, y: 0 };

        // 繪製函數
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 畫線 (簡單連接)
            ctx.strokeStyle = '#bdc3c7';
            ctx.lineWidth = 2;
            nodes.forEach(node => {
                if (node.id > 1) { // 簡單邏輯：讓下層連到 RD 部門
                    ctx.beginPath();
                    ctx.moveTo(node.x + 60, node.y);
                    ctx.lineTo(400 + 60, 80 + 40);
                    ctx.stroke();
                }
            });

            // 畫節點
            nodes.forEach(node => {
                const isHighlighted = highlightedGroup && node.group === highlightedGroup;
                
                // 陰影與樣式
                ctx.fillStyle = isHighlighted ? '#e74c3c' : node.color;
                ctx.shadowBlur = isHighlighted ? 20 : 5;
                ctx.shadowColor = isHighlighted ? 'rgba(231, 76, 60, 0.5)' : 'rgba(0,0,0,0.1)';
                
                // 方塊
                ctx.beginPath();
                ctx.roundRect(node.x, node.y, 120, 40, 5);
                ctx.fill();

                // 文字
                ctx.shadowBlur = 0;
                ctx.fillStyle = 'white';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(node.text, node.x + 60, node.y + 25);
            });

            requestAnimationFrame(draw);
        }

        // 滑鼠互動邏輯
        canvas.onmousedown = (e) => {
            const { clientX, clientY } = e;
            selectedNode = nodes.find(n => 
                clientX >= n.x && clientX <= n.x + 120 &&
                clientY >= n.y && clientY <= n.y + 40
            );

            if (selectedNode) {
                isDragging = true;
                offset.x = clientX - selectedNode.x;
                offset.y = clientY - selectedNode.y;
                
                // --- 這裡定義點擊觸發邏輯 ---
                // 邏輯：點擊一個，同組(group)全亮
                highlightedGroup = selectedNode.group;
            } else {
                highlightedGroup = null;
            }
        };

        window.onmousemove = (e) => {
            if (isDragging && selectedNode) {
                selectedNode.x = e.clientX - offset.x;
                selectedNode.y = e.clientY - offset.y;
            }
        };

        window.onmouseup = () => {
            isDragging = false;
        };

        draw();
    </script>
</body>
</html>